{"mappings":"sEACAA,OAAOC,eAAeC,EAAS,aAAc,CACzCC,OAAO,IAEXD,EAAQE,QACR,SAAyBC,EAAUC,GAC/B,KAAMD,aAAoBC,GACtB,MAAM,IAAIC,UAAU,oC,WCG5B,SAASC,EAAkBC,EAAQC,GAC/B,IAAI,IAAIC,EAAI,EAAGA,EAAID,EAAME,OAAQD,IAAI,CACjC,IAAIE,EAAaH,EAAMC,GACvBE,EAAWC,WAAaD,EAAWC,aAAc,EACjDD,EAAWE,cAAe,EACtB,UAAWF,IAAYA,EAAWG,UAAW,GACjDhB,OAAOC,eAAeQ,EAAQI,EAAWI,IAAKJ,E,EAftDb,OAAOC,eAAeiB,EAAS,aAAc,CACzCf,OAAO,IAEXe,EAAQd,QACR,SAAsBE,EAAaa,EAAYC,GACvCD,GAAYX,EAAkBF,EAAYe,UAAWF,GACrDC,GAAaZ,EAAkBF,EAAac,GAChD,OAAOd,C,ECiJX,IAAMgB,EAAO,CACXC,SAAUC,SAASC,cAAc,6BACjCC,QAASF,SAASC,cAAc,4BAChCE,UAAWH,SAASC,cAAc,kBA+H9BG,EAAQ,IAAV,W,sBA3DEC,EACQC,G,IAAAC,EAAAD,EAAEC,O,aACZC,KAAKC,WAAa,KAClBD,KAAKE,UAAW,EAChBF,KAAKD,OAASA,EAGdC,KAAKG,M,iBAGPlB,IAAA,O,MAAA,WACE,IAAMmB,EAAOJ,KAAKK,kBAAkB,GACpCL,KAAKD,OAAOK,E,IAGdnB,IAAA,Q,MAAA,W,WACE,IAAIe,KAAKE,SAAT,CAGA,IAAMI,EAAYC,KAAKC,MACvBR,KAAKE,UAAW,EAEhBF,KAAKC,WAAaQ,aAAY,WAC5B,IAEMC,EAFcH,KAAKC,MAEOF,EAG1BF,EAAOO,EAAKN,kBAAkBK,GACpCC,EAAKZ,OAAOK,E,GACX,IAbD,C,IAeJnB,IAAA,O,MAAA,WACE2B,cAAcZ,KAAKC,YACnBD,KAAKE,UAAW,EAGhB,IAAME,EAAOJ,KAAKK,kBAAkB,GACpCL,KAAKD,OAAOK,E,IAIdnB,IAAA,M,MAAA,SAAId,GACF,OAAO0C,OAAO1C,GAAO2C,SAAS,EAAG,I,IAOnC7B,IAAA,oB,MAAA,SAAkBmB,GAMhB,MAAO,CAAEW,MALKf,KAAKgB,IACjBC,KAAKC,MAAMd,EAAS,MAAyB,OAI/Be,KAFHnB,KAAKgB,IAAIC,KAAKC,MAAMd,EAAS,KAAoB,MAExCgB,KADTpB,KAAKgB,IAAIC,KAAKC,MAAMd,EAAS,IAAc,M,OAIxD,GAAU,CAAU,CACtBL,OAeF,SAAyBD,G,IAAEiB,EAAFjB,EAAEiB,MAAOI,EAATrB,EAASqB,KAAMC,EAAftB,EAAesB,KACtC9B,EAAKK,UAAU0B,YAAc,GAAYC,OAATP,EAAM,KAAWO,OAARH,EAAK,KAAQG,OAALF,E,IAZ5B9B,EAAlBC,SAASgC,iBAAiB,SAAS,WACtC3B,EAAM4B,O,IAGmBlC,EAAtBI,QAAQ6B,iBAAiB,SAAS,WACrC3B,EAAM6B,M","sources":["node_modules/@swc/helpers/lib/_class_call_check.js","node_modules/@swc/helpers/lib/_create_class.js","src/js/session-17(асинхронность, таймеры).js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = _classCallCheck;\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = _createClass;\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\n","// Метод window.setTimeout(callback, delay, args)\n// setTimeout:\n// вызывает определенную функцию через определенное время\n// const logMessage = () => {\n// console.log('лог при вызове callback-функции через 3 секи');\n// };\n// console.log('до вызова setTimeout');\n// setTimeout(() => {\n//   console.log('Внутри callback для setTimeout');\n// }, 2000);\n// console.log('После вызова setTimeout');\n\n// ===\n// останавливаем setTimeout\n// const logger = time => {\n//   console.log(`лог через ${time}ms, потому что не отменили таймаут`);\n// };\n// const timerId = setTimeout(logger, 2000, 2000);\n// console.log(timerId);\n\n// const shouldCancelTimer = Math.random() > 0.3;\n// console.log(shouldCancelTimer);\n\n// if (shouldCancelTimer) {\n//   clearTimeout(timerId);\n// }\n\n// ======================================================\n// Метод setInterval(callback, delay, args)\n// -вызывает функцию с переодичностью в какое то время, пока не отменишь его\n// const logger = time => console.log(`Лог каждые${time}ms - ${Date.now()}`);\n// console.log('До вызова setInterval');\n// setInterval(logger, 2000, 2000);\n// console.log('После вызова setInterval');\n\n// ===\n// Останавливаем интервал с clearInterval(intervalId)\n// const intervalId = setInterval(logger, 2000, 2000);\n// const shouldCancelInterval = Math.random() > 0.3;\n// console.log(shouldCancelInterval);\n// if (shouldCancelInterval) {\n//   clearInterval(intervalId)\n// }\n\n// ============================================================\n// Уведомлялка\n// -Показываем и скрываем добавляя\\удаляя класс is-visible\n// -Скрываем через определенное время\n// -Скрываем при клике\n// -Не забываем чистить таймер\n\n// const NOTIFICATION_DELAY = 3000;\n// let timeoutId = null;\n// const refs = {\n//   notification: document.querySelector('.js-alert'),\n// };\n// refs.notification.addEventListener('click', onNotificationClick);\n// showNotification();\n\n// // Функции:\n// function onNotificationClick() {\n//   hideNotification();\n//   // очищаем setTimeout если был клик по уведомлялке\n//   clearTimeout(timeoutId);\n// }\n\n// function showNotification() {\n//   refs.notification.classList.add('is-visible');\n\n//   timeoutId=setTimeout(() => {\n//     console.log('закрываем автоматически, если не было клика');\n//     // --закрываем уведомлялку автоматически через 3секи\n//     hideNotification();\n//   }, NOTIFICATION_DELAY);\n// };\n// // --функция закрытия уведомлялки\n// function hideNotification() {\n//   refs.notification.classList.remove('is-visible');\n// };\n\n// ===========================================================\n// ===Модальное окно надоедалки через интервал\n// import BSN from 'bootstrap.native';\n// const refs = {\n//   modal: document.querySelector('.modal'),\n//   subscribeBtn:document.querySelector('.btn-primary'),\n// };\n// let promptCounter = 0;\n// let hasSubscribed = false;\n// const PROMPT_DELAY = 1000;\n// const MAX_PROMPT_ATTEMPTS = 3;\n// const modal = new BSN.Modal('.modal');\n\n// // открываем модалку при открытии страницы\n// openModal();\n// // hide.bs.modal событие с бутстрапа для модалки\n// refs.modal.addEventListener('hide.bs.modal', () => {\n//   openModal()\n// })\n// // при клике на подписаться, делаем переменную тру и закрываем окно\n// refs.subscribeBtn.addEventListener('click', () => {\n//   hasSubscribed = true;\n//   modal.hide();\n\n// })\n// // если достигли лимита открытий модалки или переменная тру, то ретерн и больше не открываем\n// function openModal() {\n//   if (promptCounter === MAX_PROMPT_ATTEMPTS || hasSubscribed) {\n//     return;\n//   }\n//     setTimeout(() => {\n//       console.log('открываем надоедалку');\n//       modal.show();\n//       promptCounter += 1;\n//     }, PROMPT_DELAY);\n// }\n\n// ===Надоедалка\n// let promptCounter = 0;\n// let hasSubscribed = false;\n\n// const intervalId=setInterval(() => {\n//   if (promptCounter === MAX_PROMPT_ATTEMPTS || hasSubscribed) {\n//     console.log('нужно оставновить интервал');\n//     clearInterval(intervalId);\n//     // --ретерн тут нужен что бы функция остановилась\n//     return;\n//   }\n//     console.log('PODPISHIS-' + Date.now());\n//   promptCounter += 1;\n// }, PROMPT_DELAY);\n\n// ==============================================================\n// Дата и время\n// -Создание\n// -Unix-время\n// -Методы\n// -Разница времени\n// -Date.now()\n\n// // Unix-время это точка отсчета от которой компьютеры считают время 1 января 1970года 00:00\n// const date = new Date();\n// console.log(date.getTime());\n\n// ищем разницу во времени, запоминаем одно время, потом вызываем функцию и запоминаем второе время и записываем эти данные\n// const date1 = Date.now();\n// setTimeout(() => {\n//   const date2 = Date.now();\n//   console.log(date2 - date1);\n// },3000)\n\n// ============================================================\n// Делаем Таймер\nconst refs = {\n  startBtn: document.querySelector('button[data-action-start]'),\n  stopBtn: document.querySelector('button[data-action-stop]'),\n  clockface: document.querySelector('.js-clockface'),\n};\n\n// const timer = {\n//   intervalId: null,\n//   isActive: false,\n//   start() {\n//     if (this.isActive) {\n//       return;\n//     }\n//     const startTime = Date.now();\n//     this.isActive = true;\n//     // Вызываем запланированную функцию каждый раз с интервалом в 1секу\n//     this.intervalId = setInterval(() => {\n//       const currentTime = Date.now();\n//       // получаем разницу во времени\n//       const deltaTime = currentTime - startTime;\n\n//       // получаем время в функции getTimeComponents которая возвращает время в своем формате\n//       const time = getTimeComponents(deltaTime);\n\n//       // через функцию updateClockface которая деструктуризирует и выводит время в формате который нам нужен и рисует нам интерфейс\n//       updateClockface(time);\n//     }, 1000);\n//   },\n//   stop() {\n//     clearInterval(this.intervalId);\n//     this.isActive = false;\n//   },\n// };\n// автоматически запускает таймер:\n// timer.start()\n\n// // Запускает таймер при Клике\n// refs.startBtn.addEventListener('click', () => {\n//   timer.start();\n// });\n// // Останавливает таймер при клике\n// refs.stopBtn.addEventListener('click', () => {\n//   timer.stop();\n// });\n\n// // -Принимает время в миллисекундах\n// // -Высчитывает сколько в них вмещается часов\\минут\\секунд\n// // -Рисует интерфейс\n// function updateClockface({ hours, mins, secs }) {\n//   refs.clockface.textContent = `${hours}:${mins}:${secs}`;\n// }\n\n// // Принимает число, приводит к строке и добавляе в начало 0 если число меньше 2х знаков\n// function pad(value) {\n//   return String(value).padStart(2, '0');\n// }\n\n// // -Принимает время в миллисекундах\n// // - Высчитывает сколько в них вмещается часов\\минут\\секунд\n// // - Возвращает обьект со свойствами hours, mins, secs\n// // - Адская копипаста со стека\n// function getTimeComponents(time) {\n//   const hours = pad(\n//     Math.floor((time % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60))\n//   );\n//   const mins = pad(Math.floor((time % (1000 * 60 * 60)) / (1000 * 60)));\n//   const secs = pad(Math.floor((time % (1000 * 60)) / 1000));\n//   return { hours, mins, secs };\n// }\n\n// Делаем таймер через класс==============================================\nclass Timer {\n  constructor({ onTick }) {\n    this.intervalId = null;\n    this.isActive = false;\n    this.onTick = onTick;\n\n    // отображение циферблата\n    this.init();\n  };\n\n  init() {\n    const time = this.getTimeComponents(0);\n    this.onTick(time);\n  }\n  \n  start() {\n    if (this.isActive) {\n      return;\n    }\n    const startTime = Date.now();\n    this.isActive = true;\n    // Вызываем запланированную функцию каждый раз с интервалом в 1секу\n    this.intervalId = setInterval(() => {\n      const currentTime = Date.now();\n      // получаем разницу во времени\n      const deltaTime = currentTime - startTime;\n\n      // получаем время в функции getTimeComponents которая возвращает время в своем формате\n      const time = this.getTimeComponents(deltaTime);\n      this.onTick(time);\n    }, 1000);\n  }\n  stop() {\n    clearInterval(this.intervalId);\n    this.isActive = false;\n\n    // при нажатии на стоп, очищаем поле\n    const time = this.getTimeComponents(0);\n    this.onTick(time);\n  }\n\n  // Принимает число, приводит к строке и добавляе в начало 0 если число меньше 2х знаков\n  pad(value) {\n    return String(value).padStart(2, '0');\n  }\n\n  // -Принимает время в миллисекундах\n  // - Высчитывает сколько в них вмещается часов\\минут\\секунд\n  // - Возвращает обьект со свойствами hours, mins, secs\n  // - Адская копипаста со стека\n  getTimeComponents(time) {\n    const hours = this.pad(\n      Math.floor((time % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60))\n    );\n    const mins = this.pad(Math.floor((time % (1000 * 60 * 60)) / (1000 * 60)));\n    const secs = this.pad(Math.floor((time % (1000 * 60)) / 1000));\n    return { hours, mins, secs };\n  }\n}\nconst timer = new Timer({\n  onTick: updateClockface,\n});\n\n// Запускает таймер при Клике\nrefs.startBtn.addEventListener('click', () => {\n  timer.start();\n});\n// Останавливает таймер при клике\nrefs.stopBtn.addEventListener('click', () => {\n  timer.stop();\n});\n\n// -Принимает время в миллисекундах\n// -Высчитывает сколько в них вмещается часов\\минут\\секунд\n// -Рисует интерфейс\nfunction updateClockface({ hours, mins, secs }) {\n  refs.clockface.textContent = `${hours}:${mins}:${secs}`;\n}"],"names":["Object","defineProperty","$665014edacbfe17b$exports","value","default","instance","Constructor","TypeError","$74e7f8130373505f$var$_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","$74e7f8130373505f$exports","protoProps","staticProps","prototype","$241141dc41e1fe0e$var$refs","startBtn","document","querySelector","stopBtn","clockface","$241141dc41e1fe0e$var$timer","Timer","param","onTick","this","intervalId","isActive","init","time","getTimeComponents","startTime","Date","now","setInterval","deltaTime","_this","clearInterval","String","padStart","hours","pad","Math","floor","mins","secs","textContent","concat","addEventListener","start","stop"],"version":3,"file":"session-17(асинхронность, таймеры).93f31291.js.map"}